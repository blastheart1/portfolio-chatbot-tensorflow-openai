import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Send, X, Brain, Save, XCircle } from 'lucide-react';
import { MessageBubble, Message } from './MessageBubble';
import { TensorFlowService } from '../lib/tensorflowModel';
import { OpenAIService } from '../lib/openaiService';

interface ChatWindowProps {
  isOpen: boolean;
  onClose: () => void;
  tensorflowService: TensorFlowService;
  openaiService: OpenAIService;
  onLearningExample: (userInput: string, openAiResponse: string) => Promise<{success: boolean, reason?: string}>;
}

// Configuration for AI response customization
const AI_RESPONSE_CONFIG = {
  // Set to empty string to remove prefix entirely
  // Set to custom text to change the prefix
  // Set to null to use default prefix
  prefix: "", // Change this to customize the AI response prefix
  
  // Alternative examples:
  // prefix: "ðŸ¤– AI Response:", 
  // prefix: "Generated by AI:",
  // prefix: "", // No prefix
  // prefix: "Here's what I found:",
};

export const ChatWindow: React.FC<ChatWindowProps> = ({
  isOpen,
  onClose,
  tensorflowService,
  openaiService,
  onLearningExample,
}) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [showLearningPrompt, setShowLearningPrompt] = useState(false);
  const [pendingLearning, setPendingLearning] = useState<{userInput: string, openAiResponse: string} | null>(null);
  const [isDarkMode, setIsDarkMode] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Detect dark mode
  useEffect(() => {
    const checkDarkMode = () => {
      setIsDarkMode(document.documentElement.classList.contains('dark') || 
                   window.matchMedia('(prefers-color-scheme: dark)').matches);
    };
    
    checkDarkMode();
    
    // Listen for theme changes
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    mediaQuery.addEventListener('change', checkDarkMode);
    
    // Listen for class changes on document
    const observer = new MutationObserver(checkDarkMode);
    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
    
    return () => {
      mediaQuery.removeEventListener('change', checkDarkMode);
      observer.disconnect();
    };
  }, []);

  // Helper function to format AI response with customizable prefix
  const formatAIResponse = (content: string): string => {
    if (AI_RESPONSE_CONFIG.prefix === "") {
      // No prefix - return content as is
      return content;
    } else if (AI_RESPONSE_CONFIG.prefix === null) {
      // Use default prefix
      return `This answer is generated by AI beyond the FAQ dataset.\n\n${content}`;
    } else {
      // Use custom prefix
      return `${AI_RESPONSE_CONFIG.prefix}\n\n${content}`;
    }
  };

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Focus input when chat opens
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen]);

  // Add welcome message when chat first opens
  useEffect(() => {
    if (isOpen && messages.length === 0) {
      const welcomeMessage: Message = {
        id: 'welcome',
        content: "Hi! I'm Luis's AI assistant. I can tell you about his background, skills, services, and hobbies. I also learn from our conversations to get better over time! What would you like to know?",
        isUser: false,
        timestamp: new Date(),
        source: 'faq',
      };
      setMessages([welcomeMessage]);
    }
  }, [isOpen, messages.length]);

  // Simple keyword-based FAQ matching as fallback
  const findSimpleFAQMatch = (userMessage: string): { response: string } | null => {
    const message = userMessage.toLowerCase();
    
    // Simple keyword matching for common questions
    const faqMatches = [
      {
        keywords: ['who are you', 'what do you do', 'introduce yourself', 'your name', 'hi', 'hello', 'hey'],
        response: "My name is Luis. I am a software developer and team manager with strong expertise in building modern web applications, AI-powered solutions, and business rule management systems."
      },
      {
        keywords: ['skills', 'programming', 'languages', 'typescript', 'javascript', 'react', 'java', 'c++'],
        response: "I specialize in TypeScript and JavaScript for modern web development. I also have a solid foundation in Java and C++ from earlier projects."
      },
      {
        keywords: ['chatbot', 'ai', 'tensorflow', 'openai', 'machine learning'],
        response: "Yes. I design scalable chatbots using TensorFlow for intent recognition and OpenAI for conversational flow, with customizable datasets depending on client needs."
      },
      {
        keywords: ['hobbies', 'rc cars', 'cycling', 'coffee', 'sim racing', 'youtube'],
        response: "I have several hobbies including RC car builds (Tamiya kits), cycling (road and gravel), coffee brewing, and sim racing. I share these on my YouTube channel Sunraku-san TV."
      },
      {
        keywords: ['contact', 'email', 'linkedin', 'reach you', 'hire', 'freelance'],
        response: "You can reach me via LinkedIn or email, both of which are listed on my portfolio website. I'm open to freelance opportunities in full-stack development, AI chatbot design, and QA process optimization."
      },
      {
        keywords: ['background', 'experience', 'career', 'work'],
        response: "I started with Java, C++, and quality assurance, but I have since upskilled to full-stack development with TypeScript, ReactJS, and TailwindCSS. My career also includes experience as a BRMS developer and QA team manager."
      }
    ];

    for (const match of faqMatches) {
      if (match.keywords.some(keyword => message.includes(keyword))) {
        return { response: match.response };
      }
    }
    
    return null;
  };

  const handleSendMessage = async () => {
    if (!inputValue.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      content: inputValue.trim(),
      isUser: true,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setIsTyping(true);

    try {
      let response: Message;
      let usedOpenAI = false;
      let openAiResponse = '';

      // First try TensorFlow.js intent recognition
      if (tensorflowService.isModelReady()) {
        console.log('ðŸ¤– Using TensorFlow.js model for intent recognition');
        const prediction = await tensorflowService.classifyInput(userMessage.content);
        
        if (prediction) {
          // High confidence FAQ match
          response = {
            id: (Date.now() + 1).toString(),
            content: prediction.response,
            isUser: false,
            timestamp: new Date(),
            source: 'faq',
            confidence: prediction.confidence,
          };
        } else {
          console.log('ðŸ“š Low confidence from TensorFlow, trying OpenAI...');
          // Low confidence, try OpenAI
          if (openaiService.isConfigured()) {
            try {
              const aiResponse = await openaiService.generatePortfolioResponse(userMessage.content);
              openAiResponse = aiResponse.content;
              usedOpenAI = true;
              response = {
                id: (Date.now() + 1).toString(),
                content: formatAIResponse(aiResponse.content),
                isUser: false,
                timestamp: new Date(),
                source: 'ai',
              };
            } catch (openaiError) {
              console.warn('OpenAI error, falling back to FAQ:', openaiError);
              response = {
                id: (Date.now() + 1).toString(),
                content: "I'm not sure about that. You can reach out to Luis directly for more specific questions!",
                isUser: false,
                timestamp: new Date(),
                source: 'faq',
              };
            }
          } else {
            response = {
              id: (Date.now() + 1).toString(),
              content: "I'm not sure about that. You can reach out to Luis directly for more specific questions!",
              isUser: false,
              timestamp: new Date(),
              source: 'faq',
            };
          }
        }
      } else {
        console.log('âš ï¸ TensorFlow model not ready, using simple keyword matching...');
        // Model not ready, try simple keyword matching first
        const simpleMatch = findSimpleFAQMatch(userMessage.content);
        if (simpleMatch) {
          response = {
            id: (Date.now() + 1).toString(),
            content: simpleMatch.response,
            isUser: false,
            timestamp: new Date(),
            source: 'faq',
          };
        } else if (openaiService.isConfigured()) {
          try {
            const aiResponse = await openaiService.generatePortfolioResponse(userMessage.content);
            openAiResponse = aiResponse.content;
            usedOpenAI = true;
            response = {
              id: (Date.now() + 1).toString(),
              content: formatAIResponse(aiResponse.content),
              isUser: false,
              timestamp: new Date(),
              source: 'ai',
            };
          } catch (openaiError) {
            console.warn('OpenAI error, falling back to FAQ:', openaiError);
            response = {
              id: (Date.now() + 1).toString(),
              content: "I'm not sure about that. You can reach out to Luis directly for more specific questions!",
              isUser: false,
              timestamp: new Date(),
              source: 'faq',
            };
          }
        } else {
          response = {
            id: (Date.now() + 1).toString(),
            content: "I'm not sure about that. You can reach out to Luis directly for more specific questions!",
            isUser: false,
            timestamp: new Date(),
            source: 'faq',
          };
        }
      }

      // Simulate typing delay
      setTimeout(() => {
        setMessages(prev => [...prev, response]);
        setIsTyping(false);

        // Show learning prompt if OpenAI was used
        if (usedOpenAI && openAiResponse) {
          setPendingLearning({
            userInput: userMessage.content,
            openAiResponse: openAiResponse
          });
          setShowLearningPrompt(true);
        }
      }, 1000);

    } catch (error) {
      console.error('Error generating response:', error);
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: "Sorry, I encountered an error. Please try again or contact Luis directly.",
        isUser: false,
        timestamp: new Date(),
        source: 'faq',
      };
      setMessages(prev => [...prev, errorMessage]);
      setIsTyping(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleLearningDecision = async (shouldLearn: boolean) => {
    if (shouldLearn && pendingLearning) {
      const result = await onLearningExample(pendingLearning.userInput, pendingLearning.openAiResponse);
      
      if (!result.success) {
        // Show error message to user
        const errorMessage: Message = {
          id: `error_${Date.now()}`,
          content: `âŒ Learning failed: ${result.reason}`,
          isUser: false,
          timestamp: new Date(),
          source: 'faq',
        };
        setMessages(prev => [...prev, errorMessage]);
      } else {
        // Show success message
        const successMessage: Message = {
          id: `success_${Date.now()}`,
          content: "âœ… I've learned from this example and will remember it for future conversations!",
          isUser: false,
          timestamp: new Date(),
          source: 'faq',
        };
        setMessages(prev => [...prev, successMessage]);
      }
    }
    setShowLearningPrompt(false);
    setPendingLearning(null);
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0, scale: 0.8, y: 20 }}
          animate={{ opacity: 1, scale: 1, y: 0 }}
          exit={{ opacity: 0, scale: 0.8, y: 20 }}
          transition={{ duration: 0.3, ease: "easeOut" }}
          className="fixed bottom-6 right-6 w-96 h-[500px] bg-white rounded-2xl shadow-2xl border border-gray-200 flex flex-col z-50"
        >
          {/* Header */}
          <div 
            className="flex items-center justify-between p-4 border-b border-gray-200 text-white rounded-t-2xl"
            style={{
              background: isDarkMode 
                ? 'linear-gradient(to right, #ffffff, #0033a0)' 
                : 'linear-gradient(to right, #000000, #0033a0)',
              color: isDarkMode ? '#000000' : '#ffffff'
            }}
          >
            <div className="flex items-center space-x-2">
              <img 
                src="/LuisBot.ico" 
                alt="LuisBot" 
                className="w-6 h-6"
              />
              <div>
                <h3 className="font-semibold">Luis's AI Assistant</h3>
                <p className="text-xs opacity-90">Self-improving chatbot</p>
              </div>
            </div>
            <button
              onClick={onClose}
              className="p-1 hover:bg-white hover:bg-opacity-20 rounded-full transition-colors"
            >
              <X className="w-5 h-5" />
            </button>
          </div>

          {/* Messages */}
          <div className="flex-1 overflow-y-auto p-4 bg-chat-bg">
            {messages.map((message) => (
              <MessageBubble key={message.id} message={message} />
            ))}
            
            {/* Typing indicator */}
            {isTyping && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="flex justify-start mb-4"
              >
                <div className="bg-chat-bubble-bot text-gray-800 border border-chat-border rounded-2xl rounded-bl-md px-4 py-3">
                  <div className="flex space-x-1">
                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                  </div>
                </div>
              </motion.div>
            )}
            <div ref={messagesEndRef} />
          </div>

          {/* Learning Prompt */}
          {showLearningPrompt && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              className="p-3 bg-blue-50 border-t border-blue-200"
            >
              <div className="flex items-center space-x-2 text-sm text-blue-800 mb-2">
                <Brain className="w-4 h-4" />
                <span className="font-medium">Should I remember this answer?</span>
              </div>
              <div className="flex space-x-2">
                <button
                  onClick={() => handleLearningDecision(true)}
                  className="flex items-center space-x-1 px-3 py-1 bg-blue-500 text-white rounded-full text-xs hover:bg-blue-600 transition-colors"
                >
                  <Save className="w-3 h-3" />
                  <span>Yes, remember</span>
                </button>
                <button
                  onClick={() => handleLearningDecision(false)}
                  className="flex items-center space-x-1 px-3 py-1 bg-gray-500 text-white rounded-full text-xs hover:bg-gray-600 transition-colors"
                >
                  <XCircle className="w-3 h-3" />
                  <span>No, thanks</span>
                </button>
              </div>
            </motion.div>
          )}

          {/* Input */}
          <div className="p-4 border-t border-gray-200">
            <div className="flex space-x-2">
              <input
                ref={inputRef}
                type="text"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Ask me anything about Luis..."
                className="flex-1 px-4 py-2 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                disabled={isTyping}
              />
              <button
                onClick={handleSendMessage}
                disabled={!inputValue.trim() || isTyping}
                className="p-3 bg-blue-500 text-white rounded-full hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center min-w-[48px] min-h-[48px]"
              >
                <Send className="w-5 h-5" />
              </button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};